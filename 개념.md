## 개념

--------------------------
### 색션2. 스프링 핵심 원리 이해

※ IoC( Inversion of Control ) 제어의 역전
- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행한다. 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름이다.
- 반면에 AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 이제 AppConfig가 가져간다. 예를 들어서 `OrderServiceImpl` 은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될 지 모른다.
- 프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. 심지어 `OrderServiceImpl` 도 AppConfig가 생성한다. 그리고 AppConfig는 `OrderServiceImpl이` 아닌 OrderServie 인터페이스의 다른 구현 객체를 생성하고 실행할 수 도 있다. 그런 사실도 모른체 `OrderServiceImpl`은 묵묵히 자신의 로직을 실행할 뿐이다.
- 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.

※ 프레임워크/라이브러리
- 프레임워크 : 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크 (JUnit)
- 라이브러리 : 내가 작성한 코드가 직접 제어의 흐름을 담당

※ DI( Dependency Injection ) 의존관계 주입
- `OrderServiceImpl`은 `DiscountPolicy`인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.
- 의존관계는 **정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체 의존 관계**들을 분리해서 생각해야 한다.

※ 정적인 클래스 의존 관계
- 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.

※ 동적인 클래스 의존 관계
- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.
- 애플리케이션 **실행 시점(런타임)**에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 **의존관계 주입**이라 한다.
- 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
- 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고(코드를 변경하지 않고), 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

※ Ioc 컨테이너, DI 컨테이너
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을
- IoC 컨테이너 또는 **DI 컨테이너**라 한다.
- 의존관계 주인에 초점을 맞추어 최근에는 주로 DI 컨테이너라고 한다.
- 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.

※ 스프링 컨테이너
- `ApplicationConext`를 스프링 컨테이너라 한다.
- 기존에는 개발자가 `AppConfig`를 사용해서 직접 객체를 생성하고 Di를 했지만, 이제부터는 스프링 컨테이너를 등록해서 사용한다.
- 스프링 컨테이너는 `@Configration` 이 붙은 `AppConfig`를 설정(구성) 정보로 사용한다. 여기서 `@Bean`이라 적힌 메소드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- 스프링 빈은 `@Bean`이 붙은 메소드의 명을 스프링 빈의 이름으로 사용한다. (`memberService`, `orderService`)
- 이전에는 개발자가 필요한 객체를 `AppConfig`를 사용해서 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈을 찾아야 한다. 스프링 빈은 `applicationContext.getBean()`메소드를 사용해서 찾을 수 있다.
- 기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.
---------------------

### 색션4. 스프링 컨테이너와 스프링 빈

※ BeanFactory (interface)
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할 담당
- `getBean()`을 제공

※ ApplicationContext (interface)
- BeanFactory 기능을 모두 상속받아서 제공
- 빈을 관리하고 검색하는 기능을 BeanFactory가 제공해주는데, 둘이 차이는?
- 애플리케이션을 개발할 떄는 빈은 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능이 필요

- 부가 기능 (interface)
  - MessageSource (메세지소스를 활요한 국제화 기능) 
    - 예를 들어 한국에서 들어오면 한국어, 영어권에서 들어오면 영어로 출력 (파일을 여러개로 미리 분리해서 가져옴)
  - EnvironmentCapable (환경변수)
    - 로컬, 개발, 운영등 구분해서 처리
  - ApplicationEventPublisher (애플리케이션 이벤트)
    - 이벤트를 발행하고 구독하는 모델을 편히라게 지원ㅔ
  - ResourceLoader(편리한 리소스 조회)
    - 파일, 클래스 패스, 외부 등에서 리소스를 편리하게 조회

- 정리
  - ApplicationContext는 BeanFactory의 기능을 상속받는다.
  - ApplicationContext는 빈 관리 기능 + 편리한 부가 기능을 제공한다.
  - BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
  - BeanFactory나 ApplicationContext를 스프링 컨테이너라고 한다.

※ 스프링 빈 설정 메타 정보 - BeanDefinition
- `BeanDefinition` : 스프링의 다양한 설정 형식 지원
- **역할과 구현을 개념적으로 나눈 것**
  - XML을 읽어서 BeanDefinition을 만든다.
  - 자바 코드를 읽어서 DeanDefinition을 만든다.
  - 스프링 컨테이너는 자바 코드인지, XML인지 몰라도 되고 BeanDefinition만 알면 된다.
- `BeanDefinition`을 빈 성정 메타정보라 한다.
  - `@Bean`,`<bean>` 당 각각 하나씩 메타 정보가 생성된다.
  - 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.
  
- BeanDefinition 정보
  - BeanClassName : 생성할 빈의 클레스 명 (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)
  - factoryBeanName : 팩토리 역할의 빈을 사용할 경우 ex) appConfig
  - factoryMethodName : 빈 생성할 팩토리 메서드 지정 ex) memberService
  - Scope : 싱글톤 (default)
  - lazyInit : 스프링 컨테이너를 생성할 때 빈을 생성하는것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부
  - InitMethodName : 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메소드 명
  - DestroyMethodName : 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메소드 명
  - Constructor arguments, Properties : 의존관계 주입에서 사용한다. (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)

---------------------

### 색션5. 싱글톤 컨테이너

※ 싱글톤 패턴
- 객체가 딱 하나 존재

- 단점
  - 구현하는 코드 자체가 많이 들어간다.
  - 의존관계상 클라이언트가 구체 클래스에 의존 --> DIP 위반
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙 위반 가능성 높음
  - 테스트 어려움
  - 내부 속성을 변경하거나 초기화 어려움
  - private 생성자로 자식 클래스 만들기 어려움
  - 결론적으로 유연성 떨어짐
  - 안티 패턴으로 불림

※ 싱글톤 컨테이너
- 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리
- 스프링 빈 == 싱글톤으로 관리되는 빈

- 싱글톤 컨테이너
  - 스프링 컨테이너는 싱그톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
  - 스프링 컨테이너는 싱글콘 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 한다.
  - 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
    - 싱글톤 패턴을 위한 지저분한 코드가 없어도 됨.
    - DIP, OCP 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.

※ 싱글톤 방식의 주의점
- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 살계하면 안된다.!!!
- 무상태(stateless)로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신 자바에서 공유되지 않는, 지역번수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다. => 공유필드는 조심하자!

※ Configuration과 바이트코드 조작의 마법
- `CGLIB`예상 코드
```yml
@Bean
public MemberRepository memberRepository(){
  if(MemoryMemberRepository 이미 스프링 컨테이너에 등록되어 있으면?){
    return 스프링 컨테이너에서 찾아서 반환;
  } else{
    기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록
    return 반환;
  }
}
```
