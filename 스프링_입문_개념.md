## 개념

--------------------------
### 색션2. 스프링 핵심 원리 이해

※ IoC( Inversion of Control ) 제어의 역전
- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행한다. 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름이다.
- 반면에 AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 이제 AppConfig가 가져간다. 예를 들어서 `OrderServiceImpl` 은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될 지 모른다.
- 프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. 심지어 `OrderServiceImpl` 도 AppConfig가 생성한다. 그리고 AppConfig는 `OrderServiceImpl이` 아닌 OrderServie 인터페이스의 다른 구현 객체를 생성하고 실행할 수 도 있다. 그런 사실도 모른체 `OrderServiceImpl`은 묵묵히 자신의 로직을 실행할 뿐이다.
- 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.

※ 프레임워크/라이브러리
- 프레임워크 : 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크 (JUnit)
- 라이브러리 : 내가 작성한 코드가 직접 제어의 흐름을 담당

※ DI( Dependency Injection ) 의존관계 주입
- `OrderServiceImpl`은 `DiscountPolicy`인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.
- 의존관계는 **정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체 의존 관계**들을 분리해서 생각해야 한다.

※ 정적인 클래스 의존 관계
- 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.

※ 동적인 클래스 의존 관계
- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.
- 애플리케이션 **실행 시점(런타임)** 에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 **의존관계 주입**이라 한다.
- 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
- 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고(코드를 변경하지 않고), 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

※ Ioc 컨테이너, DI 컨테이너
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을
- IoC 컨테이너 또는 **DI 컨테이너**라 한다.
- 의존관계 주인에 초점을 맞추어 최근에는 주로 DI 컨테이너라고 한다.
- 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.

※ 스프링 컨테이너
- `ApplicationConext`를 스프링 컨테이너라 한다.
- 기존에는 개발자가 `AppConfig`를 사용해서 직접 객체를 생성하고 Di를 했지만, 이제부터는 스프링 컨테이너를 등록해서 사용한다.
- 스프링 컨테이너는 `@Configration` 이 붙은 `AppConfig`를 설정(구성) 정보로 사용한다. 여기서 `@Bean`이라 적힌 메소드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- 스프링 빈은 `@Bean`이 붙은 메소드의 명을 스프링 빈의 이름으로 사용한다. (`memberService`, `orderService`)
- 이전에는 개발자가 필요한 객체를 `AppConfig`를 사용해서 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈을 찾아야 한다. 스프링 빈은 `applicationContext.getBean()`메소드를 사용해서 찾을 수 있다.
- 기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.
---------------------

### 색션4. 스프링 컨테이너와 스프링 빈

※ BeanFactory (interface)
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할 담당
- `getBean()`을 제공

※ ApplicationContext (interface)
- BeanFactory 기능을 모두 상속받아서 제공
- 빈을 관리하고 검색하는 기능을 BeanFactory가 제공해주는데, 둘이 차이는?
- 애플리케이션을 개발할 떄는 빈은 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능이 필요

- 부가 기능 (interface)
  - MessageSource (메세지소스를 활요한 국제화 기능) 
    - 예를 들어 한국에서 들어오면 한국어, 영어권에서 들어오면 영어로 출력 (파일을 여러개로 미리 분리해서 가져옴)
  - EnvironmentCapable (환경변수)
    - 로컬, 개발, 운영등 구분해서 처리
  - ApplicationEventPublisher (애플리케이션 이벤트)
    - 이벤트를 발행하고 구독하는 모델을 편히라게 지원ㅔ
  - ResourceLoader(편리한 리소스 조회)
    - 파일, 클래스 패스, 외부 등에서 리소스를 편리하게 조회

- 정리
  - ApplicationContext는 BeanFactory의 기능을 상속받는다.
  - ApplicationContext는 빈 관리 기능 + 편리한 부가 기능을 제공한다.
  - BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
  - BeanFactory나 ApplicationContext를 스프링 컨테이너라고 한다.

※ 스프링 빈 설정 메타 정보 - BeanDefinition
- `BeanDefinition` : 스프링의 다양한 설정 형식 지원
- **역할과 구현을 개념적으로 나눈 것**
  - XML을 읽어서 BeanDefinition을 만든다.
  - 자바 코드를 읽어서 DeanDefinition을 만든다.
  - 스프링 컨테이너는 자바 코드인지, XML인지 몰라도 되고 BeanDefinition만 알면 된다.
- `BeanDefinition`을 빈 성정 메타정보라 한다.
  - `@Bean`,`<bean>` 당 각각 하나씩 메타 정보가 생성된다.
  - 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.
  
- BeanDefinition 정보
  - BeanClassName : 생성할 빈의 클레스 명 (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)
  - factoryBeanName : 팩토리 역할의 빈을 사용할 경우 ex) appConfig
  - factoryMethodName : 빈 생성할 팩토리 메서드 지정 ex) memberService
  - Scope : 싱글톤 (default)
  - lazyInit : 스프링 컨테이너를 생성할 때 빈을 생성하는것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부
  - InitMethodName : 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메소드 명
  - DestroyMethodName : 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메소드 명
  - Constructor arguments, Properties : 의존관계 주입에서 사용한다. (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)

---------------------

### 색션5. 싱글톤 컨테이너

※ 싱글톤 패턴
- 객체가 딱 하나 존재

- 단점
  - 구현하는 코드 자체가 많이 들어간다.
  - 의존관계상 클라이언트가 구체 클래스에 의존 --> DIP 위반
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙 위반 가능성 높음
  - 테스트 어려움
  - 내부 속성을 변경하거나 초기화 어려움
  - private 생성자로 자식 클래스 만들기 어려움
  - 결론적으로 유연성 떨어짐
  - 안티 패턴으로 불림

※ 싱글톤 컨테이너
- 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리
- 스프링 빈 == 싱글톤으로 관리되는 빈

- 싱글톤 컨테이너
  - 스프링 컨테이너는 싱그톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
  - 스프링 컨테이너는 싱글콘 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 한다.
  - 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
    - 싱글톤 패턴을 위한 지저분한 코드가 없어도 됨.
    - DIP, OCP 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.

※ 싱글톤 방식의 주의점
- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 살계하면 안된다.!!!
- 무상태(stateless)로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신 자바에서 공유되지 않는, 지역번수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다. => 공유필드는 조심하자!

※ Configuration과 바이트코드 조작의 마법
- `CGLIB`예상 코드
```yml
@Bean
public MemberRepository memberRepository(){
  if(MemoryMemberRepository 이미 스프링 컨테이너에 등록되어 있으면?){
    return 스프링 컨테이너에서 찾아서 반환;
  } else{
    기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록
    return 반환;
  }
}
```

---------------------

### 색션6. 컴포넌트 스캔

※ @ComponentScan
- 런타임 시 스프링에서 `@Component`가 붙은 클래스들을 모두 찾아 스프링 빈에 등록한다.
- AppConfig로 수동 등록시 의존관계도 수동으로 지정해 줬지만, 해당 어노테이션을 쓰면 생성자에 `@Autowired` 어노테이션을 적으면 자동으로 찾아서 의존관계를 주입해준다.

※ 탐색 위치와 기본 스캔 대상
- 모든 자바 클래스를 다 컴포넌트 스캔하면 시간이 오래 걸림 그래서 범위 지정이 가능
```java
@ComponentScan(
        basePackages = "com.karim.spring.basic.server"
)
```
- basePackages : 탐색할 패키지의 시작 위치를 지정. 하위 패키지 모두 탐색 (여러개 가능)
- basePackageClasses : 지정한 클래스의 패키지를 탐색 시작 위로 지정 
- !!만약 지정하지 않으면!!
  - `@ComponentScan`이 붙은 설정 접보 클래스의 패키지가 시작 위치가 된다.
- 권장 방법 : 프로젝트 최상단에 두자! (최금 스프링 부트도 이 방법을 기본적으로 제공)
- `@SpringBootApplication`안에 `@ComponentScan`이 들어가 있음

※ 컴포넌트 스캔 기본 대상
- `@Component` : 컴포넌트 스캔에서 사용
- `@Controller` : 스프링 MVC 컨트롤러에서 사용
  - 스프링 MVC 컨트롤러로 인식
- `@Service` : 스프링 비즈니스 로직에서 사용
  - 특별한 처리 X, 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나라고 인식하는데 도움이 됨
- `@Repository` : 스프링 데이터 접근 계층에서 사용
  - 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환
- `@Configuration` : 스프링 설정 정보에서 사용
  - 스프링 설정 정보로 인삭하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다. (`CGLIB`예)

- 참고 : 애노테이션에는 상속관계가 없다. 따라서 위에 있는 어노테이션은 스프링이 지원하는 기능 (절대 자바 X)
- 참고 : `useDefaultFilters`옵션은 기본으로 ture, 이 옵션을 끄면 기본 스캔 대상들(위 정리)이 제외된다.

※ 필터
- `includeFilters` : 컴포넌트 스캔 대상을 추가로 지정한다.
- `excludeFilters` : 컴포넌트 스캔에서 제외할 대상을 지정한다.

※ FilterType 옵션   
- `ANNOTATION`(default) : 어노테이션을 인식해서 동작한다.
  - ex) org.example.SomeAnnotation
- `ASSIGNABKE_TYPE` : 지정한 타입과 자식 타입을 인식해서 동작한다.
  - ex) org.example.SomeClass
- `ASPECTJ` : AspectJ 패턴 사용
  - ex) org.example..*Service+
- `REGEX` : 정규 표현식
  - ex) org\.example\.Default.*
- `CUSTOM` : `TypeFilter`라는 인터페이스를 구현해서 처리
  - ex) org.example.MyTypeFilter

※ 컴포넌트 스캔 시 스프링 빈 중복 등록과 충돌
- 자동 빈 등록 vs 자동 빈 등록
  - `ConflictingBeanDefinitionException` 예외 발생
- 수동 빈 등록 vs 자동 빈 등록
  - 수동 빈 등록이 우선권을 가진다. (수동 빈이 자동 빈을 오버라이딩 해버린다.) // 예전
  - 현재는 `spring.main.allow-bean-definition-overriding=false`로 되어있어 구동 시 에러난다.

---------------------

### 색션7. 의존관계 자동 주입

※ 의존관계 주입 종류 및 특정
- 생성자 주입
  - 생성자에 `@Autowired` 설정 (생성자 하나면 생략 가능)
  - 특징
    - 생성자 호출 시점에 딱 1번만 호출되는 것이 보장
    - **분변,필수** 의존관계에 사용
- setter 주입 (수정자 주입)
  - 필드의 값을 변경하는 setter 메소드를 통해 의존관계를 주입
  - 특징
    - **선택,변경** 가능성이 있는 의존관계에 사용
    - 자바빈 프로퍼티 규약의 수정자 메소드 방식을 사용하는 방법
  - 참고
    - `@Autowired`의 기본 동작은 주입할 대상이 없으면 오류, 주입할 대상이 없어도 동작하게 하려면 `@Autowired(required = false)`로 지정하면 된다.
- 필드 주입
  - 필드에 `@Autowired` 설정
  - 특징
    - 코드가 간결
    - 하지만 외부에서 변경이 불가능해 테스트 하기 힘듬
    - DI 프레임워크가 있을 때만 테스트 가능
    - 사용하지 말자!
      - 애플리케이션의 실제 코드와 관계 없는 테스트 코드
      - 스프링 설정을 목적으로 하는 `@Configuration` 같은 곳에서만 특별한 용도로 사용
- 일반 메소드 주입
  - 생성자가 아닌 일반 메소드에 `@Autowired` 설정
  - 특징
    - 한번에 여러 필드를 주입 받을 수 있다.
    - 일반적으로 잘 사용하지 않음

※ 주입할 스프링 빈이 없어도 동작해야 할 때 사용하는 **옵션 처리**
- **@Autowired(required=false)**
  - 자동 주입할 대상이 없으면 수정자 메소드 자체가 호출 안됨
- **org.springframework.lang.@Nullable**
  - 자동 주입할 대상이 없으면 null이 입력된다.
- **Optional<>**
  - 자동 주입할 대상이 없으면 `Optional.empty`가 입력된다.

※ 생성자 주입을 선택해라!
- **불변**
  - 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.
  - 수정자 주입을 사용하면 setXxx 메소드를 public으로 열어두어야 한다 (변할 가능성 높음)
  - 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.
- **누락**
  - 생성자 주입일 시 프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우에 의존관계를 누락 없이 넣을 수 있다. (tool에서 에러 보여줌)
  - 수정자 주입일 시 순수 자바 코드를 단위 테스트 하는 경우에는 의존관계를 지정 안하면 누락되어 null exception이 발생한다.
- **final 키워드 사용 가능**
  - 생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다.
  - 생성자에서 혹시라도 값이 설정되지 않는 오류를 `컴파일 시점`에 막아준다.
- **정리**
  - 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이기도 한다.
  - 기본으로 생성자 주입을 사용하구, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.
  - 항상 생성자 주입을 선택해라! 그리고 가끔 옵션이 필요하면 수정자 주입을 선택해라.
  - 필드 주입은 사용하지 않는게 좋다.

※ 롬복과 최신 트랜드
- **@RequiredArgsConstructor**
  - final 변수인 애들로 생성자를 만들어 준다. (생성자 자동 주입)
  - 생성자가 1개면 `@Autowired`를 생략할 수 있다.

※ 조회 빈이 2개 이상일 때 (문제)
- FixDiscountPolicy, RateDiscountPolicy 둘다 스프링 빈으로 등록이 되어 있으면
  - `NoUniqueBeanDefinitionException` 발생
- 이때 하위 타입으로 지정할 수 도 있지만, 하위 타입으로 지정하는 것은 DIP를 위배하고 유연성이 떨어진다.
- 그리고 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결이 안된다.
- 스프링 빈을 수동 들록해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 방법이 여러있다.

※ 조회 빈이 2개 이상일 때 (문제 해결 방법)
- `@Autowired` 필드명 매칭
  1. 타입 매칭으로 시도
  2. 이 때 여러 빈이 있으면
  3. 생성자의 필드 이름 (파라미터 이름)
  5. 으로 빈 이름을 추가 매칭한다.
- `@Qualifier` -> `@Qualifier`끼리 매칭 -> 빈 이름 매칭
  - 추가 구분자를 붙여주는 방식
  - 주입시 추가적인 방법을 제공하는 것으로 빈 이름을 변경하는 것은 아니다.
  - 만약 못찾으면? 
    - @Qualifier("name") 로 찾는 name으로 스프링 빈을 추가로 찾는다.
- `@Primary` 사용 (자주 사용)
  - 우선 순위를 지정하는 방법
  - `@Primary`이 있는 빈이 제일 우선 순위를 가진다.
- `@Qualifier` > `@Primary` (우선순위는 `@Qualifier`가 더 높다)

※ 조회한 빈이 모두 필요할 때, List, Map
- C:\Users\karim\spring-basic-server\src\test\java\com\karim\spring\basic\server\autowired\allBean\AllBeanTest.java

※ 자동, 수동의 올바른 실무 운영 기준
- 자동 주입을 선호
- 수동 빈 등록은 언제 사용하면 좋을까?
  - **업무로직** : 웹을 지원하는 컨트롤러, 핵심 비지니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 레포지토리등 모두 업무 로직
  - **기술 지원 빈** : 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용. 데이터베시으 연결이나, 공통 로그 처리 처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들
  - 업무 로직은 숫자도 많고, 한번 개발하면 컨트롤러 서비스 리포지토리 처럼 어느 정도 유사한 패턴
    - 이런 경우는 `자동 빈 등록`을 하는 것이 좋다.
    - 보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 명확하게 파악하지 쉬움
  - 기술 지원 빈같은 경우는 수가 적고, 어플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다.
    - 이런 경우는 가급적 `수동 빈 등록`을 하는 것이 좋다.
  - 비지니스 로직 중에서 **다형성**을 활용할 경우
    - 다른 개발자를 혼란 시키지 않게 `수동 빈 등록`을 하는 것이 좋다.
      - ex) fixDiscountPolicy, rateDiscountPolicy
  - 스프링 부트가 아니라 내가 직접 기술 지원 객체를 스프링 빈으로 등록 한다면 `수동 빈 등록`을 하는 것이 좋다.

- 정리
  - 편리한 자동 기능을 기본으로 사용하자
  - 직접 등록하는기술 지원 객체는 수동 등록 사용하자
  - 다형성을 적극 활용하는 비지니스 로직은 수동 등록을 고민하자.

---------------------

### 색션8. 빈 생명주기 콜백

※ 빈 생명주기 콜백 시작
- DB 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.

※ 빈 라이플 사이클
- **객체 생성** -> **의존 관계 주입**
- 스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.
- 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다.
- 근데 어떻게 완료된 시점을 알 수 있을까?
  > `스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메소드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공`한다.
  > 또한 `스프링은 스프링 컨테이너가 종료되기 직전에 고멸 콜백`을 준다. 따라서 안전하게 종료 작업을 진행할 수 있다.

※ 스프링 빈의 이벤트 라이플 사이클
- **스프링 컨테이너 생성** -> **스프링 빈 생성** -> **의존관계 주입** -> **초기화 콜백** -> **사용** -> **소멸전 콜백** -> **스프링 종료**
- 초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
- 소멸전 콜백 : 빈이 소멸되기 직전에 호출

※ 객체의 생성과 초기화를 분리하자!

※ 인터페이스 InitializingBean, DisposableBean 
- 빈의 초기화와 소멸을 관리해준다.
- 단점
  - 스프링 전용 인터페이스라서 코드가 스프링 전용 인터페이스에 의존하다.
  - 초기화, 소멸 메소드의 이름을 변경할 수 없다.
  - 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.
- 해당은 초창기 방법이고, 요즘은 사용하지 않는다.

※ 빈 등록 초기화, 소멸 메소드
- `@Bean(initMethod = "init", destroyMethod = "close")` 처럼 초기화, 소멸 메소드를 지정할 수 있다.
- 특징
  - 메소드 이름을 마음대로 할 수 있다.
  - 스프링 빈이 스프링 코드에 의존하지 않는다.
  - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리도 초기화/종료 할 수 있다.
- 종료 메소드 추론
  - `destroyMethod` 속성에는 아주 특별한 기능이 ㅇㅆ다.
  - 라이브버리는 대부분 `close`, `shutdown`이라는 이름의 종료 메소드를 사용한다.
  - `destroyMethod`의 기본값이 `(inferred)` 추론으로 등록되어ㅕ 있다.
  - 이 추론 기능은 `close`, `shutdown` 라는 메소드를 자동으로 호출해준다. 이름 그대로 종료 메소드를 추론해서 호출
  - 따라서 직접 스프링 빈으로 등록하면 종료 메소드는 따로 적어주지 않아도 잘 동작한다.
  - 추론 기능을 사용하기 싫으면 `destroyMethod` 처럼 공백을 지정하면 된다.

※ 애노테이션 @PostConstruct, @PreDestroy (이걸로 사용하자)
- 최신 스프링에서 가장 권장하는 방법
- 어노테이션 하나만 붙이면 되므로 매우 편리
- 스프링이 아닌 다른 컨테이너에서도 동작
- 컴포넌트 스캔과 잘 어울린다.
- 단점
  - 외부 라이브러리에는 적용하지 못한다는것
  - 외부 라이브러리를 초기화, 종료 해야 한면 @Bean의 기능을 사용하자
- 정리
  - @PostConstruct, @PreDestroy (이걸로 사용하자)
  - 코드를 고칠 수 없는 외부 라이브러리를 초기화 종료해야 한다면
  - `@Bean(initMethod = "init", destroyMethod = "close")`를 사용하자

---------------------

### 색션9. 빈 스코프란?

※ 빈 스코프란?
- 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때 까지 유지된다고 학습했다.
- 이것은 스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문이다.
- 스코프는 번역 그대로 빈이 존재할 수 있는 범위를 뜻한다.

※ 스프링이 지원하는 스코프
- **싱글톤** : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
- **프로토타입** : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지않는 매우 짧은 범위의 스코프이다.
- **웹 관련 스코프**
  - **request** : 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
  - **session** : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
  - **application** : 웹 서블릿 컨텍스와 같은 범위로 유지되는 스코프

※ 스코프 적용
- 컨포넌트 스캔 자동 등록
```java
@Scope("prototype")
@Component
public class HelloBean{
}
```
- 수동 등록
```java
@Scope("prototype")
@Bean
public class HelloBean{
    return new HelloBean();
}
```

※ 프로토타입 스코프
1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.
3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.
4. 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환다.

**정리**
- **핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다.**
- 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다.
- 프로토타입 빈을 관할 책임은 프로토타입 빈을 받은 클라이언트에 있ㅆ다.
- 그래서 `@PreDestory`같은 종료 메소드가 호출되지 않는다.

**프로토타입 정리**
- 스프링 컨테이너에 요청할 때 마다 새로 생성된다.
- 스프링 컨테이너는 프로토타입 빈의 생성과 의존 관계 주입 그리고 초기화까지만 관여한다.
- 종료 메소드가 호출되지 않는다.
- 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다.
- 종료 메소드에 대한 호출도 클라이언트가 직접 해야한다.

※ 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결
- 싱글톤 빈과 프로토타입 빈을 같이 사용할 때, 항상 새로운 프로토 타입 빈 생성하고 싶을 경우
  - 싱글톤 빈이 프로토 타입을 사용할 때마다 스프링 컨테이너에 새로 요청
  > ac.getBean() 으로 항상 새로운 프로토타입 빈 생성 -> 복잡

1. ObjectProvider
  - `getObject()` 을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)
  - 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기 훨씬 쉬워진다.
  - `ObjectProvider`는 딱 DL 기능만 제공

2. JSR-330 Provider (자바 표준)
   - `get()` 을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)
   - 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기 훨씬 쉬워진다.
   - `Provider`는 딱 DL 기능만 제공

※ 웹 스코프
- 웹 환경에서만 동작
- 프로토타입과 다르게 스프링이 스코프 종료시점까지 관리 따라서 종료 메소드가 호출된다.

- 웹 스코프 종류
  - **request** : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
  - **session** : HTTP Session과 동일한 생명주기를 가지는 스코프
  - **application** : 서블릿 컨텍스트(`ServletContext`)와 동일한 생명주기를 가지는 스코프
  - **websocket** : 웹 소켓과 동일한 생명주기를 가지는 스코프

- 싱글톤이 아닌 다른 스코프들은 진짜 최소한으로 사용하자!